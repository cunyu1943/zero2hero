[TOC]

## 1. 变量

### 1.1 什么是变量？

所谓变量，就是用来命名一个数据的标识符，在 Java 中，变量又可以分为两种：

-   **基本类型的变量**
-   **引用类型的变量**

```java
// 基本类型的变量
int id = 1;
// 引用类型的变量
String name = "村雨遥";
```

其中 `int` 是基本数据类型，表示这是一个整型数；而 `String` 则是引用类型，表示这是一个引用类型；

`id` 和 `name` 则是标识符，也就是我们所说的 **变量**；

`=` 则是赋值操作符，而 `1` 则是基本类型的值，`村雨遥` 则是引用类型的值；

### 1.2 变量的特点

变量的最重要的一个特点就是可以重新赋值；

```java
public class Main {
    public static void main(String[] args) {
		// 定义int类型变量id，并赋予初始值1
        int id = 1; 
		// 打印该变量的值，观察是否为1
        System.out.println(id); 
 		// 重新赋值为2
        id = 2; 
        // 打印该变量的值，观察是否为2
        System.out.println(id); 
    }
}
```

### 1.3 变量命名规则

变量命名也是一门学问，并不是我们想怎么命名就怎么命名，日常开发中最常见的变量命名规则主要有如下几条：

1.  变量命名只能使用 **字母（大小写均可）、数字、$、_**；
2.  变量名不能使用关键字（就是 Java 中内置的一些关键字，如 `int、for、long……`）；
3.  变量第一个字符不能使用数字，只能用字母、`$`、`_`；
4.  更多命名规则推荐参考阿里巴巴推出的《Java 开发手册》，关注公众号 **村雨遥【cunyu1943】**，回复 **资源下载** 可获取最新版！

### 1.4 常见关键字

![Java 关键字](https://cdn.jsdelivr.net/gh/cunyu1943/image-hosting-for-blog/imgJava%20%E5%85%B3%E9%94%AE%E5%AD%97.png)

## 2. 数据类型



### 2.1 基本数据类型

Java 中，共有 8 中基本数据类型，由 Java 语言预定好的，每个数据类型都属于关键字，而且每种基本变量都有其对应的封装类；

| 数据类型  | bit    | 字节   | 封装类      | 数据范围                             | 默认值  |
| --------- | ------ | ------ | ----------- | ------------------------------------ | ------- |
| `byte`    | 8      | 1      | `Byte`      | $-2^7$ ~ $2^7-1$                     | `0`     |
| `short`   | 16     | 2      | `Short`     | $-2^{15}$ ~ $2^{15}-1$               | `0`     |
| `char`    | 16     | 2      | `Character` | `\u0000` ~ `\uffff`（$0$ ~ $65535$） | `u0000` |
| `int`     | 32     | 4      | `Integer`   | $-2^{31}$ ~ $2^{31}-1$               | `0`     |
| `long`    | 64     | 8      | `Long`      | $-2^{63}$ ~ $2^{63}-1$               | `0L`    |
| `float`   | 32     | 4      | `Float`     | $3.4e^{-45}$ ~ $1.4e^{38}$           | `0.0f`  |
| `double`  | 64     | 8      | `Double`    | $4.9e^{-324}$ ~ $1.8e^{308}$         | `0.0D`  |
| `boolean` | 不确定 | 不确定 | `Boolean`   | `true` 或 `false`                    | `false` |

**注意：** 

1.  `boolean` 一般用 1 `bit` 来存储，但是具体大小并未规定，JVM 在编译期将 `boolean` 类型转换为 `int`，此时 1 代表 `true`，`0` 代表 `false`。此外，JVM 还指出 `boolean` 数组，但底层是通过 `byte` 数组来实现;
2.  使用 `long` 类型时，需要在后边加上 `L`，否则将其作为整型解析，可能会导致越界；
3.  浮点数如果没有明确指定 `float` 还是 `double`，统一按 `double` 处理；
4.  `char` 是用 **单引号 `''`** 将内容括起来，相当于一个整型值（ASCII 值），能够参加表达式运算；而 `String` 是用 **双引号 `""`** 将内容括起来，代表的是一个地址值；
5.  Java 在内存中是采用 Unicode 表示，所以无论是一个中文字符还是英文字符，都能用 `char` 来表示；

那么如何个一个基本类型变量赋值呢？

在 Java 中，基本数据类型属于 Java 的一种内置的特殊数据类型，不属于任何类，所以可以直接对其进行赋值；给基本类型的变量赋值的方式就叫做 **字面值**；

```java
float score = 89.0f;
int age = 26;
```

### 2.2 引用数据类型

#### 2.2.1 常见引用数据类型

| 数据类型 | 默认值 |
| -------- | ------ |
| 数组     | `null` |
| 类       | `null` |
| 接口     | `null` |

而对于引用数据类型，我们经常是需要 `new` 关键字来进行赋值，但是引用类型中的 **接口是不能被实例化的**；

```java
// 初始化一个对象
Pet dog = new Pet();
// 初始化一个数组
int[] arr = new int[10];
```

#### 2.2.2 String

对于引用数据类型中的 `String`，我们需要特别关注。

`String` 不同于 `char`，它属于引用类型，而 `char` 属于基本数据类型。用双引号 `""` 括起来表示字符串，一个字符串能够保存 0 个到任意个字符。

而针对字符串，如果我们要打印一些特殊的字符，比如字符串本来就包含 `"`，那么这个时候就需要借助于转义字符 `\`，最常见的转义字符主要有：

| 转义字符 | 含义         |
| -------- | ------------ |
| `\"`     | 字符 `"`     |
| `\'`     | 字符 `'`     |
| `\\`     | 字符 `\`     |
| `\n`     | 换行符       |
| `\t`     | 制表符 `Tab` |
| `\r`     | 回车符       |

>   那多个字符串之间或者字符串和其他类型数据之间，该如何进行连接呢？

Java 编译器中，对于字符串和其他数据类型之间，可以使用 `+` 进行连接，编译器会自动将其他数据类型自动转换为字符串，然后再进行连接；

>   `String` 既然是不可变，那有什么优点呢？

1.  **用于缓存 `hash` 值**

由于 `String` 的 `hash` 值被频繁使用，它的不可变性使得 `hash` 值也不可变，此时只需要进行一次计算；

2.  **字符串常量池（String Pool）的需要**

如果一个 `String` 对象已经被创建过，那么就会优先从字符串常量池中获取其引用，其不可变性确保了不同引用指向同一 `String` 对象；

3.  **安全性**

我们经常用 `String` 作为我们方法的参数，其不变性能够保证参数不可变；

4.  **线程安全**

`String` 的不可变性让它天生 **具备线程安全**，能够在多个线程中方便使用而不用考虑线程安全问题。

>   `String、StringBuilder、StringBuffer` 对比，该如何选择？

|                 | 可变性 | 线程安全                               | 适用场景                                                     |
| --------------- | ------ | -------------------------------------- | ------------------------------------------------------------ |
| `String`        | 不可变 | 安全                                   | 操作少量的数据                                               |
| `StringBuffer`  | 可变   | 安全，内部使用 `synchronized` 进行同步 | 多线程操作字符串缓冲区下操作大量数据                         |
| `StringBuilder` | 可变   | 不安全                                 | 单线程操作字符串缓冲区下操作大量数据，性能高于 `StringBuffer` |

>   通过 `new String(“xxx”)` 创建字符串的两种情况？

使用 `new` 的方式创建字符串对象，会有两种不同的情况：

1.  **String Pool 中不存在 “xxx”**

此时会创建两个字符串对象，“xxx” 属于字符串字面量，因此在编译期会在 String Pool 中创建一个字符串对象，用于指向该字符串的字面量 “xxx”；然后 `new` 会在堆中创建一个字符串对象；

![](https://s1.ax1x.com/2020/07/25/UxXxC8.png)

2.  **String Pool 中存在 “xxx”**

此时只需要创建一个字符串对象，由于 String Pool 中已经存在指向 “xxx” 的对象，所以直接在堆中创建一个字符串对象；

![](https://s1.ax1x.com/2020/07/25/UxjpvQ.png)

### 2.3 数据类型转换

对于基本数据类型，不同类型之间是可以相互转换的，但是需要满足一定的条件；

>   **从小到大自动转，从大到小强制转**。

即就是，对于低精度的数据类型，如果要转换为高精度的数据类型，直接将低精度的值赋给高精度的值即可；

但对于高精度的数据类型，如果想要转换为低精度的数据类型，则需要采用 **强制转换** 的手段，但此时需要承担精度丢失的风险，就像从一个大杯子往一个小杯子里倒水，你要做好小杯子可能装不下溢出的情况；

```java
int a = 110;
long b = 113;
// 低精度转高精度，由于 long 的范围比 int 大，所以可以自动转
b = a;
// 高精度住哪低精度，由于 long 的范围比 int 大，所以需要强制转
a = (int)b;
```

#### 2.3.1 隐式转换（自动类型转换）

当满足如下条件时，如果将一种类型的数据赋值给另一种数据类型变量时，将执行自动类型转换：

>   1.  两种数据类型彼此兼容；
>   2.  目标数据类型的取值范围大于源数据类型；

一般而言，隐式转换的规则是从低级类型数据转换为高级类型数据，对应规则如下：

>   -   **数值类型**：`byte -> short -> int -> long -> float -> double`
>   -   **字符类型转整型**：`char -> int`

#### 2.3.2 显式转换（强制类型转换）

那既然满足上述两个条件时会发生隐式转换，那不满足同时我们又想进行数据类型转换时，我们该怎么办呢？

这个时候就需要我们的 **显式转换** 登场了，其语法格式如下：

```java
(type) variableName;
```

我们举个 🌰 来说下：

```java
int num = 3;
double ans = 5.0;
// 要将 double 类型的值赋值给 int，则需要强制
num = (int)ans;
```

#### 2.3.3 常见数据类型转换方法

1.  **字符串与其他类型之间的转换**

-   **其他类型 -> 字符串**

>   1.  调用类的串转换方法：`X.toString()`；
>   2.  自动转换：`"" + X`；
>   3.  利用 `String` 的方法：`String.valueOf(X)`；

-   **字符串 - > 其他类型**

调用 `parseXXX` 方法，比如 `parseLong、parseFloat、parseDouble...`；

2.  **int、float、double** 之间的转换

-   `float -> double`

```java
float num = 1.0f;
Float num1 = new Float(num);
double num2 = num1.doubleValue();
```

-   `double -> float`

```java
double num = 100.0;
float num1 = (float)num;
```

-   `double -> int`

```java
double num = 100.0;
Double num1 = new Double(num);
int num2 = num1.intValue();
```

-   `int -> double`

```java
int num = 200;
double num1 = num;
```

![](https://gitee.com/cunyu1943/images/raw/master/ImgsUbuntu/20200510234310.png)

